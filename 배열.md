# 배열 기초 문법



### 왜 필요한가?

- 일일히 변수를 선언하게 되면, 변수 이름을 매번 지어줘야 하고, 코드가 길어진다.
- 따라서 배열을 만듦으로써 코드를 간략하게 할 수 있다.



### 1. 배열 생성법

```cpp
배열 변수 생성
int tmp[4] = {0,1,2,3};
tmp[0]=0; tmp[1]=1; tmp[2]=2; tmp[3]=3;
```



### 2. 배열의 형식

- 자료형 + 배열의 이름[배열의 크기]={배열 요소};
- 이 중에서도 배열의 이름은 메모리 공간의 시작 주소를 의미한다. 즉 포인터 이다.



### 3. 배열의 초기화 방법

```cpp
int tmp1[4] = {1,2};
int tmp2[] = {1,2,3,4};
char tmp3[12] = "I'm Hero!";
```



1. 첫 번째는 배열의 크기에 못 미치게 배열 요소를 넣었다. 이렇게 초기화 하게 되면 입력하지 않은 부분은 모두 0으로 초기화 된다. 다시 말해 아래와 같은 결과가 된다.

  ```
  int tmp[4] = {1,2};
  tmp[0] = 1; tmp[1] = 2; tmp[2] = 0; tmp[3] = 0;
  ```



- 두 번째는 배열의 크기를 선언하지 않고 요소만 넣었다. 이렇게 초기화 하게 되면 배열의 크기는 요소에 맞춰 자동으로 선언된다. 다시말해 아래와 같은 결과가 된다.

  ```
  int tmp2[] = {1,2,3,4};
  int tmp2[4]
  ```



- 세 번째는 문자열을 저장하는 배열이다. 이 배열에는 공백과 특수문자도 포함하여 모두 배열값에 저장하게 되고, 배열의 요소를 받지 못한 부분은 모두 NULL값으로 초기화 된다.

- 위와 같이 만들어진 배열은 가상 메모리 영역중 스텍이라는 영역에 저장 된다. 이 스택 영역에 저장되게 되면, 프로그래머가 배열을 수정하기 힘들어 진다. 만일 배열의 크기를 10으로 선언한다면, 코드가 끝날 때 까지 그 배열은 10개의 값만 가질 수 있다. 이러한 단점을 극복하기 위해 배열을 가상 메모리중 힙 영역에 저장하는 방법이 있다.



### 4. 배열을 힙 영역에 저장하기

- 배열을 힙 영역에 저장하는 방법은 두 가지가 있다. (malloc, calloc)

- malloc : 메모리 영역만 생성한다

- calloc : 메모리 영역의 요소들을 모두 0으로 초기화까지해준다.

- 따라서 쓰레기값을 없애주는 calloc을 주로 사용하는 것을 권장한다.

- 힙 영역에 저장하는 방식의 예제 코드

  ```
  int * temp1 = (int *)calloc(10, sizeof(int));
  int * temp2 = (int *)malloc(10, sizeof(int));
  ```

  힙 영역에 배열을 생성하게 되면 함부로 접근할 수 없다. 그 배열의 첫 번째 주소를 받는 포인터 변수로만 접근 가능하다.

  malloc과 calloc 모두 자료형이 void * 이기 때문에, int형 요소들을 저장하기 위해서는 강제형변환 int *를 사용해야 한다.

  calloc의 10은 배열의 크기, sizeof(int)는 int형, 즉 4바이트로 배열을 읽기 위해 사용했다. malloc또한 마찬가지 이다.

- 위와 같이 힙 영역에 배열을 만들게 되면 realloc으로 배열의 크기를 늘리거나 줄일 수 있다. 코딩 중간에 수정하기가 수월하다.

- 힙 영역에 저장된 배열에 접근하는 예제

  ```
  for (int i=0; i<10; i++)
  {
      scanf("%d", &temp1[i]);
      printf("%d", temp1[i]);
  }
  
  free(temp1);
  temp1 = NULL;
  ```

  이렇게 힙 영역에 할당된 배열을 다 사용했으면 free로 메모리를 해제시키는 것을 습관화 하면 좋다. 그리고 해제를 했다면, 포인터 변수에 NULL값을 넣어 잘못된 사용을 방지한다.

  이러한 1차원 배열을 이용한 간단한 코드들을 살펴보도록 한다.



### 5. 배열의 요소 중 가장 큰 값 구하기

```
int main()
{
    int vae[5] = {1,2,3,4,5};
    int max = vae[0];
    for(int i=1; i<5; i++)
    {
        if(vae[i]>max)
        {
            max = vae[i]; 
        }
    }
}

% max에는 배열의 요소 중 가장 큰 값이 저장된다.
```



### 6. 무작위의 숫자 얻어내기

```
int main()
{
    int rand_num;
    srand((unsigned)time(NULL));
    rand_num = rand()%10+1 
}

% rand()%10+1 부분은 rand()를 10으로 나눈 나머지값에 1을 더하는 것 이므로 1~10값 중 무작위로 한 개의 값이 저장된다.
```



### 7. 배열의 역순 만들기

```
int main()
{
    int vae[5] = {1,2,3,4,5};
    int reverse[5] = {0};
    
    for(int i=0; i<5; i++)
    {
        reverse[4-i] = vae[i];
    }
}

% reverse 배열에는 vae 배열의 요소의 값이 역순으로 저장된다.
```



### 8. 다차원 배열

- 배열에는 1차원 배열뿐만이 아닌 2차원, 3차원의 배열도 있다. 그 이상도 물론 존재한다. 각각 차원에 맞춰 배열을 사용하면 된다.

- 하지만 3차원 배열 이상은 잘 쓰이지는 않는 경향이 있다.

- 다차원 배열의 형식은 1차원 배열과 비슷하다. 배열의 크기만 추가됐을 뿐이다.

- 하지만 초기화 방식은 조금 다르다.

- 2차원 배열의 초기화 예

  ```
  $int vae[2][3] = {1,2,3,4};
  $int vae[3][3] = {{1,2},{3,4}};
  $int vae[][3] = {0};
  ```

- 첫 번째를 보면, 1행 1,2,3열에 1,2,3이 각각 저장되고, 2행 1열에 4가 저장된다.

- 두 번째를 보면, 행 단위로 묶어서 초기화 하는 방식이다. 1행에 1,2를 저장하고, 2행에 3,4를 저장한다. 요소를 받지 못한 부분은 0으로 초기화된다.

- 세 번째를 보면, 행의 크기를 주지 않는다. 이렇게 하면 받은 요소에 따라 행의 크기가 결정된다. 

- 유의할 점은 2차원 배열은 열의 크기를 꼭 선언해 주어야 한다는 점이다.



### 9. 단위 행렬 만들기

```
int main()
{
    int vae[3][3] = {0};
    for(int i=0; i<3; i++)
    {
        for(int j=0; j<3; j++)
        {
            if(i==j)
            vae[i][j] = 1;
            else
            vae[i][j] = 0;
        }
    }
}
```

2차원 배열은 이렇게 2중 for문으로 구성하는 것이 좋다. 2중 for문에서 바깥의 for문은 행, 안의 for문은 열을 반복한다. 열이 끝나면 다음 행으로 넘어가는 방식이다. 이 코드는 단위행렬을 만들어 낸다. 대각성분은 1로, 비대각 성분은 0으로 초기화 한다.